# 概念   

变量提升指的是在变量声明之前引用变量的过程。变量提升分为`var` 声明的变量提升和`function`声明的函数提升，如下：    

```js
console.log(a); // undefined
console.log(foo()); // 1

var a = 1;

function foo() {
  return 1;
}
```

# 内部机制

那在JS中为什么会有变量提升呢？要理解内部机制首先要明白两个概念：   

- **执行环境（Execution Context）**：执行环境定义了函数或变量有权访问的其他数据，可以理解为作用域，这决定了他们的行为。

- **变量对象（Variable Object）**：每个执行环境都有一个与之对应的**变量对象**，执行环境中定义的所有函数和变量都保存在这个对象中。   

执行环境的生命周期分为创建和执行两个阶段：

1. **在创建阶段会生成变量对象**（同时会建立作用域链，确定`this`指向，在此不作深入探讨）

2. 执行阶段执行相关代码，比如变量赋值、函数引用及其他执行代码

而变量对象的生成又分为三个阶段：   

1. 建立`argument`对象。

2. 检查当前执行环境中的函数声明，也就是使用`function`关键字声明的函数。如果检查到函数声明，则在变量对象中添加一个属性，属性名即函数名，属性值执行该函数所在堆内存中的引用。如果以该函数名命名的属性已经存在，则，该属性值的引用会被当前引用覆盖。   

3. 检查当前执行环境中的变量声明，也就是使用`var`关键字声明的变量。如果检查到变量声明，则在变量对象中添加一个属性，属性名即变量名，属性值为`undefined`。但注意：如果以该变量名命名的属性已经存在（只可能是在第二阶段添加的函数），为防止同名函数的引用被修改为`undefined`，则会跳过，原属性值不变。   

由执行环境的生命周期和变量对象的创建过程很容易知道：   

在执行环境的创建阶段，只要变量或函数有声明，变量对象创建过程中便会将相应的变量或者函数添加到变量对象中，此时，在执行环境的执行阶段，当代码执行时，即便在变量或函数声明前引用相应变量或函数，也不会报错，`var`声明的变量会被赋值为`undefined`，而`function`声明的函数则可以正常引用。   

> 在ES6以后的版本中，如果是用`let`或者`const`声明的变量，不允许在声明代码之前引用变量，不然会报错：`ReferenceError`，而非被赋值为`undefined` 。   
```js
console.log(a);  // Uncaught ReferenceError: a is not defined
let a = 1;
```

# 参考资料

【1】[前端基础进阶（二）：执行上下文详细图解](http://www.jianshu.com/p/a6d37c77e8db)   
【2】[前端基础进阶（三）：变量对象详解](http://www.jianshu.com/p/330b1505e41d)   





