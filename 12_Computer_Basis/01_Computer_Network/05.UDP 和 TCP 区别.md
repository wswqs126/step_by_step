# UDP

- 不可靠，无连接，无流量控制

- 为什么说 UDP 是无连接的呢，因为 UDP 套接字是由一个二元组来标识的，即目的 IP 和目的端口号，有没有发到不管，也不接受接收方的反馈信息（接收方也找不到你啊）。并且，不同服务器发来的 UDP 报文段如果具有相同的目的 IP 和目的端口号，那么这两个报文段会通过相同的目的套接字被定向到相同的进程。（TCP 的套接字是一一对应的，套接字由 ip + port 唯一决定，可能二元 UDP，可能 四元 TCP）

## UDP 优点

- 无连接

UDP 无需三次握手，拿到应用层的数据就发送，没有三次握手的时延；

- 传输过程快

不会流量控制、拥塞控制，就是发

- 分组首部小

TCP 报文段首部有 20 字节；UDP 只有 8 字节

## 常见 UDP 应用

DNS 啊，没有建立连接的时延，快很多。

> 使用哪种协议通过编程指定

# TCP

- 可靠，面向连接，通过流量控制、序号、确认和定时器保证数据正确、有序的虫发送进程传输到接收进程

- TCP 套接字由四元组决定（源 IP，源 port，目的 IP，目的 port）

- 一般四元组有一个不同（源）那就会定向到不同套接字（初始创建连接请求可以改变这点？）

- 所谓面向连接，就是客户端和服务端的套接字匹配的过程，匹配成功，就可以传输数据了（所以 UDP 也是面向连接？因为也有匹配套接字的过程？不然怎么传输数据。）

> TCP 为不同主机上的进程提供逻辑通信，而 IP 是为不同主机间提供逻辑通信

> 服务器进程会潜在的打开一个端口等待远程客户连接，如果打开这个端口的应用程序有安全漏洞，那可能会被攻击。

> 联想下跨域，不同的 协议+host+port 证明肯定是不同的进程（不同 tab，必要不充分条件，之前一个浏览器一个进程时怎么办？）发起的连接，为了避免获取其他进程的信息带来的安全隐患，所以浏览器禁止跨域。

## 可靠性传输

- TCP 在不可靠的 IP 层之上提供可靠的数据传输
- 流水线机制 ？？？？
- 累计确认：ack 中的序号之前的都已收到（收到同个 ACK 三次，快速重传，提升效率）
- TCP 单一重传计时器：超时引发重传，并且，超时时间加倍

**触发重传**：1）超时；2）收到重复 ACK（快速重传）

## 流量控制

接收窗口没有多余缓存（RevBuffer）时，限制发送发方发送速率，**避免接收方接收不了**，本质上是速度匹配机制。利用 TCP 报文段头部 RevWindow 中保存这个信息。

rwnd = RevBuffer - [LastByteRevd - LastByteRead]

> 即便 rwnd = 0, 完全满了，也能额外有个小段 发出消息，避免死锁。

## 连接管理

建立连接-拆除连接

### 连接：

- 客户端：标识位 SYN 不携带信息，但置 1，seq = c_isn，初识序列号随机；
- 服务端：同意连接 SYN = 1；ack = c_isn+1; seq = s_isn（分配缓存等资源，保留一段时间再释放，dos）;
- 客户端：SYN = 0；ack=s_isn+1; seq=c_isn+1（可以在这里发送数据中携带应用层信息）

> 如果没有第三次确认，已失效的连接请求报文段到达 sever，server 马上建立了连接，但客户端不会处理失效的请求报文，就没有任何反馈，服务器白白等待，浪费资源，第三次确认可以防止上述情况。（虽然也会等待、分配资源，但相比建立连接之后的等待、分配资源要少很多）。

失效连接请求报文段：

链接：https://www.nowcoder.com/questionTerminal/dd2e0e9a1618496baabad2abc56d9609
来源：牛客网
建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。
（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。
（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。

### 关闭连接：

四次，因为 server 的 ACK 和 FIN 不能一起发出，因为数据可能正在发送中，但为了避免 client 重复发 FIN 所以，先发一个 ACK，传输完数据再发 FIN，为了确认 client 收到最后数据，需要最后一次 ACK。

## 丢包

为什么会丢包：当网络变得拥塞时，由于路由器缓存溢出（接收到的太多，一致发不出去）引起的。

## 拥塞

- 非正式定义：发送数据太多或发送速度太快，网络无法处理。

- 表现：1）分组丢失（路由器缓存溢出，即丢包，**丢包就要重传，浪费资源**，极限是，全部都是重传的数据（都是因为延时），网络瘫痪了，只进不出）；2）分组延时过大（在路由器缓存中排队）

- 限制发送发的速率避免 **网络**（路由器）处理不了（流量控制限制发送方避免 **接收方** 处理不了）




