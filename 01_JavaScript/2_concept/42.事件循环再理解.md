# 事件循环再理解

先理解几个概念：

1. 同步代码直接在主线程中执行；
2. 异步代码由另外线程维护，~~先放入 Event Table（没找到这个词）~~，当指定事情做完（比如 setTimeout 延时或者 ajax 请求有了响应），将对应的回调函数（是否一定是函数）放入 Event Queue（~~分为宏任务队列和微任务队列~~，不对，只有宏任务队列，**微任务是在宏任务执行的时候确定的，Event Queue 中只有宏任务**）；
3. JS 引擎会检查主线程内任务是否执行完（包括当前宏任务和所有微任务，如果当次循环中，微任务队列有多个微任务，全部执行完才进行下一次循环，当次循环要执行到微任务队列为空，但宏任务一次循环执行一个），如果执行完，从 Event Queue 中取出一个函数执行；
4. 判断是否要重新渲染页面，如果要，先渲染页面，不然，检查宏任务队列是否有任务要执行；
5. 不断往复，即事件循环。

## 注意点

上面 2、3 点，当事件做完，只是将函数放入了事件队列，但如果此时主线程中还有任务还没执行完，要等主线程中的任务执行完后，然后 JS 引擎发现了主线程中的任务已执行完（一般最少 4ms，轮询也要时间啊），才执行事件队列中的函数。

所以，setTimeout 中指定的延迟时间，是将回调函数延迟放入事件队列中的时间，而不是回调函数实际延迟执行的时间（通常会有延迟）。

```js
// 第三次循环
setTimeout(() => {
    console.log(1000);
}, 1000);

// 第二次循环
setTimeout(() => {
    console.log(0);
}, 0);

// 第一次循环
console.log(1000);
```

## 关于页面渲染

常见一道考题是渲染 10000 个 li。有说拼接字符串，当然，可以，但相比这不是面试官想听到的，并且，这也不是最优解，知识缓解了压力，如果我要渲染 1000000000000000 个 li 呢？

其实，正确的思路应该是从事件循环说起。

因为执行完一个循环会检查是否要重新渲染页面，如果要，则重新渲染页面。为了保证流畅，尤其在有动画的时候，浏览器通常尝试每秒渲染 60 次，即每秒 60 帧。也即，再 1/60 s，约 16 ms 渲染一次。所以，为了保证浏览器可以正常渲染，最好每次循环时间（单个宏任务和当前循环的所有微任务）不要超过 16 ms。

一次渲染 1000 个 li 有可能超出 16 ms，那怎么办？

**放在多了循环中完成啊！**

具体参考 《js 忍者秘籍 2e》 p 349
