# 闭包再理解

## 几种定义

* 高程三版：闭包是有权访问另一个函数作用域中变量的函数；
* 你不知道的 JS：当函数记住并访问它所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行；
* JS 忍者秘籍二版：闭包允许函数访问并操作函数外部变量。

我的理解：

1.  闭包的组成：一个函数 + 这个函数中引用的变量（闭包创建了被定义时的作用域内的变量和函数的安全气泡，为后续执行闭包中的函数创建条件，闭包一词可以说很形象了）；

再看下面的例子：

```js
// setTimeout中定义的函数，算闭包么？
// 实际上也算，和全局变量 i 构成了一个闭包，但没意义，因为它后续访问的还是全局变量 i，而不同闭包间共享 i
// 这就是失去了闭包的意义
// 闭包存在的意义一般是减少全局变量的，将需要的变量直接放在自己的闭包里，不和其他闭包共享
// 看下面的例子
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000 * i);
}
```

```js
// 通过立即执行函数，目的创建函数作用域（块级作用域），这样，就将闭包中的 i 缩小到立即执行函数的接受的参数
// 而，每次执行函数，都会创建入参的副本
// 这样，每个闭包中，不仅有独立的函数，还有独立的 i，i 的值随内部函数的创建时一同确定下来的
// 还可以变化下，进一步所小闭包影响的范围
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, 1000 * i);
  })(i);
}

// 下面的版本更好理解，函数中的参数按值传递，将 i 复制给 j
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, 1000 * j);
  })(i);
}
```

```js
// 进一步所小闭包影响的范围,,,,,待解答
// for (var i = 0; i < 5; i++) {
//   setTimeout(function() {
//     console.log(i);
//   }, 1000 * i);
// }
```

```js
// 立即执行函数的目的是创建块级作用域，进而创建独立的i，ES6 的 let 可以创建独立的块级作用域，这就不需要立即执行函数了
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000 * i);
}

// 下面这个更能说明问题
for (var i = 0; i < 5; i++) {
  let j = i;
  setTimeout(function() {
    console.log(j);
  }, 1000 * i); // 这里是 j 或者 i 无所谓了
}
```

2.  闭包创建：通常是闭包组成中的函数 return 出去，并复制给另一个变量；还有一种常见场景：通过在定时器中的回调函数创建闭包。

3.  理解闭包的关键点：词法作用域及其变量查找规则；函数每次调用实际是执行函数题里面的代码。

## 闭包特点

闭包不是在创建的那一刻时的快照，而是一个真实的状态封装（包括函数及函数创建时的词法环境[[Environment]]），是占有内存的（所以说，创建太多闭包影响性能，内存占用增多）。

## 看个例子

```js
function foo() {
  let a = 1;
  function bar() {
    console.log(a);
  }
  return bar;
}

let baz = foo();
baz(); // 1
```

> baz === foo() 居然返回 false？见最后问题

分析：

* 谁是闭包：`bar` 及其定义时所访问的变量 `a`（通过此法作用域查询，在 `foo` 中找到了 `a`）；

* 为什么神奇?

如果直接打印 `baz` 的函数体，结果是：

```js
function bar() {
  console.log(a);
}
```

> ～注意，这个函数体还是对在 `foo` 中定义的 `bar` 的引用，而非定义了一个新的函数。函数一等公民嘛，可以作为值传递～ 不对！！！！ 每次执行 foo 实际是生成了新的闭包， 彼此独立，只不过， 每个闭包都有独立的函数及定义时的词法作用域（引用的值可能不一样，这也是闭包强大之处，经典的 setTimeout 问题）。

如果不通过闭包，而是直接将上述函数体写在 `foo` 外面，是无法访问 `a` 的，如下：

```js
function foo() {
  let a = 1;
}

function bar() {
  console.log(a);
}

bar(); // a is not defined
```

## 小结

闭包的存在，使得作为值的函数传来传去，并且记录了其完整的词作作用域（中访问的变量，多次调用同一个函数产生的闭包，次发作用域中的值可能随着调用发生变化）。

可以这么理解，在 `foo` 中返回的不是 `bar`，而是一个闭包，这个闭包由 `bar` 和变量 `a` 组成。

说 `a` 也不准确，更准确的说法是应该 `bar` 完整的词法作用域（作用域是一套规则，这套规则说明了可以访问哪些变量）。

所以，再改进下说法：

**`foo` 返回了一个闭包，这个闭包由 `bar` 及其词法作用域组成。** 并且，如果多次调用 `foo`，会生成完全独立的新的闭包（新的函数和作用域）。

## 问题

```js
function foo() {
  return 1;
}
let bar = foo();
let baz = foo();
console.log(bar === baz); // true
```

> 基本类型只是做值的比较。

```js
function foo() {
  return function() {};
}
let bar = foo();
let baz = foo();
console.log(bar === baz); // false
```

```js
function foo() {
  let a = {};
  return a;
}
let bar = foo();
let baz = foo();
console.log(bar === baz); // false
```

为什么基本类型为 true，而引用类型为 false？

首先明白一点：函数每次执行，都是将里面的代码执行了一遍，所以，每次都返回新的值。而引用类型，不能直接做比较，如下：

```js
{} === {}; // false
```

因为，引用类型直接用 `==` 或者 `===` 比较的话，是比较两个对象是否指向同一个内存地址。如下：

```js
let a = {},
  b = {},
  c = a;
console.log(a === b); // false
console.log(a === c); // true
```

参考：[Javascript 判断对象是否相等](http://www.fedlab.tech/archives/775.html)
