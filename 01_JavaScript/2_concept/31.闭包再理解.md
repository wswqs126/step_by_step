# 闭包再理解

## 几种定义

* 高程三版：闭包是有权访问另一个函数作用域中变量的函数；
* 你不知道的 JS：当函数记住并访问它所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行；
* JS 忍者秘籍二版：闭包允许函数访问并操作函数外部变量。

我的理解：

1.  闭包的组成：一个函数 + 这个函数中引用的变量（闭包创建了被定义时的作用域内的变量和函数的安全气泡，为后续执行闭包中的函数创建条件，闭包一词可以说很形象了）；

2.  闭包创建：通常是闭包组成中的函数 return 出去，并复制给另一个变量。

3.  理解闭包的关键点：词法作用域及其变量查找规则；函数每次调用实际是执行函数题里面的代码。

## 看个例子

```js
function foo() {
  let a = 1;
  function bar() {
    console.log(a);
  }
  return bar;
}

let baz = foo();
baz(); // 1
```

> baz === foo() 居然返回 false？见最后问题

分析：

* 谁是闭包：`bar` 及其定义时所访问的变量 `a`（通过此法作用域查询，在 `foo` 中找到了 `a`）；

* 为什么神奇?

如果直接打印 `baz` 的函数体，结果是：

```js
function bar() {
  console.log(a);
}
```

> ～注意，这个函数体还是对在 `foo` 中定义的 `bar` 的引用，而非定义了一个新的函数。函数一等公民嘛，可以作为值传递～ 不对！！！！ 每次执行 foo 实际是生成了新的闭包， 彼此独立，只不过， 每个闭包都有独立的函数及定义时的词法作用域（引用的值可能不一样，这也是闭包强大之处，经典的 setTimeout 问题）。

如果不通过闭包，而是直接将上述函数体写在 `foo` 外面，是无法访问 `a` 的，如下：

```js
function foo() {
  let a = 1;
}

function bar() {
  console.log(a);
}

bar(); // a is not defined
```

## 小结

闭包的存在，使得作为值的函数传来传去，并且记录了其完整的词作作用域（中访问的变量，多次调用同一个函数产生的闭包，次发作用域中的值可能随着调用发生变化）。

可以这么理解，在 `foo` 中返回的不是 `bar`，而是一个闭包，这个闭包由 `bar` 和变量 `a` 组成。

说 `a` 也不准确，更准确的说法是应该 `bar` 完整的词法作用域（作用域是一套规则，这套规则说明了可以访问哪些变量）。

所以，再改进下说法：

**`foo` 返回了一个闭包，这个闭包由 `bar` 及其词法作用域组成。** 并且，如果多次调用 `foo`，会生成完全独立的新的闭包（新的函数和作用域）。

## 问题

```js
function foo() {
  return 1;
}
let bar = foo();
let baz = foo();
console.log(bar === baz); // true
```

> 基本类型只是做值的比较。

```js
function foo() {
  return function() {};
}
let bar = foo();
let baz = foo();
console.log(bar === baz); // false
```

```js
function foo() {
  let a = {};
  return a;
}
let bar = foo();
let baz = foo();
console.log(bar === baz); // false
```

为什么基本类型为 true，而引用类型为 false？

首先明白一点：函数每次执行，都是将里面的代码执行了一遍，所以，每次都返回新的值。而引用类型，不能直接做比较，如下：

```js
{} === {}; // false
```

因为，引用类型直接用 `==` 或者 `===` 比较的话，是比较两个对象是否指向同一个内存地址。如下：

```js
let a = {},
  b = {},
  c = a;
console.log(a === b); // false
console.log(a === c); // true
```

参考：[Javascript 判断对象是否相等](http://www.fedlab.tech/archives/775.html)
