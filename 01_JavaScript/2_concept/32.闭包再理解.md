# 闭包再理解

在看这个例子：

```js
// a，bar 在 foo 执行完依然存在内存中
function foo() {
  let a = 1;
  function bar() {
    console.log(a);
  }
  return bar;
}

let baz = foo();
baz(); // 1
```

一般来说，一个函数执行完，其内部的局部变量就会被销毁。看下面例子：当 `foo` 执行完以后，`a`，`bar` 都会被销毁（垃圾回收），当，上述闭包的存在，使得 `a`，`bar` 不能被回收，因为外面有可能访问啊（**此时 `bar` 和 全局变量没有区别**）。

> 当然，foo 的执行上下文（的作用域链）会被销毁，但其活动对象（此时为 `a` 和 `bar`）依然存在内存中。

```js
// a，bar 在 foo 执行完被回收
function foo() {
  let a = 1;
  function bar() {
    console.log(a);
  }
  bar();
}
```

## 其他知识点

* 全局变量除非主动设置为 `null`，否则不能自动垃圾回收，一直存在内存中。闭包虽然赋予了访问函数内部变量的能力，但这也导致闭包访问的变量无法被垃圾回收（因为该变量一直处在闭包的环境中（啥环境，执行环境？垃圾回收具体细节？）），增加内存开销
