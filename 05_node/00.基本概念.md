## 非阻塞 I/O

程序中所有指令（语句）都是阻塞，前一条完了才能执行后面一条。但 CPU 速度很快，每秒 30 亿次，指令层面（依赖 CPU）的阻塞很难感受到。

但 I/O 的操作，比如网络请求、硬盘读写（node最为服务端语言，肯定经常干这事）或者数据库读写，这些操作，相对于执行程序语句，非常慢，甚至是可感知的慢。

## 事件驱动

发布-订阅（观察者）模式，I/O 异步操作结束后执行事件处理程序。

## 应用场景

1）I/O 密集场景。

- CPU 密集

程序大部分时间用来做计算，比如 压缩解压、加密解密；

- I/O 密集

程序大部分事件：文件操作、网络操作、数据库等

web 场景：静态文件读取、数据库操作、渲染页面，典型 I/O 密集。

Node 相对 Java 优势在于服务器前面处理 I/O 操作，而非后面处理其他服务，不存在替换（计算确实慢？？）。

> apache 是阻塞 I/O。

2）高并发

- java 应对：增加机器数量/或者多核。

> 进程：某个程序对某数据集合上的一次活动，操作系统进行资源分配和调度的基本单位。简单说就是一个运行的程序。
> 多进程：快速调度切换，模拟是同时进行（并发，多核可以并行）。

CPU 空转（服务员）等待 I/O（大厨做饭） 结束。

- Node：事件驱动、非阻塞 I/O，CPU 利用率很高（服务员）。

> 线程：进程内，相对独立、可调度的执行单元，共享进程中的资源。
> 多线程：也可以多任务。

## NodeJS 单线程

- 单线程只针对主进程（事件循环），至于 I/O 操作，操作系统底层怎么处理不管（多线程）；
- 另，Node 是但线程，但并不是单进程，就是说，如果 8 核 CPU，可以开 8 个进程（有 cluster 模块），然后每个进程是单线程的。不浪费 CPU 性能。

## Node 高性能前提

高并发、I/O密集，典型 Web 应用。（如果说进行 DES 解密性能比 C Java 高肯定不是啊）。

具体场景：

- WebServer

- 本地代码构建：babel，sass 等。其实从性能角度说，用 Node 不好，因为主要是 CPU 操作，也不是高并发。但前端属性，后端又不给写，就用 Node 了。

- 使用工具开发：比如爬虫，性能也一般不是最佳，但还是，前端熟悉啊。



