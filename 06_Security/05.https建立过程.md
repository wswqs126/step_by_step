简单来说：就是通过 RSA 算法交换将来通信过程中加密报文所需的对称秘钥（DES，3DES等）。

具体：

## 验证 server

需要 CA，保证响应中的证书确实是我们想请求的服务器返回来的，没有被中间人劫持，过程：

1. TCP 三次握手建立后，服务器（记为 S1）发自己的证书给客户端；
2. 客户端通过 CA 发给 S1 的证书中指明的散列算法，对 S1 的证书进行散列计算，得到散列值 H
3. 客户端通过应用 CA 的公钥，对 CA 发给 S1 的证书上的签名解密，得到散列值 H'（因为 CA 在给 S1 签发证书的时候，签名是通过 RSA 算法对 S1 证书的摘要做的加密）
4. 如果 H = H'，所以，S1 是可信赖的

## 交换对称秘钥

然后，交换将来加密用的对称算法秘钥（非对称算法虽然安全，但加密过程相对对称算法来说慢，所以上述才对摘要做非对称加密，而非对证书本身），交换以后，技能保证报文加密不被读取（Kc，Ks），又能保证完整性（Mc，Ms）

1. 客户端生成对称加密算法主秘钥，通过 S1 的公钥加密后，发给 S1
2. S1 对主秘钥用自己的私钥揭秘，然后报文就可以通过在交换后的秘钥的基础上通过对称加密算法加密后进行安全传输（对报文进行加密，保证完整性，防篡改）

实际，不是直接通过主秘钥对报文进行加密，而是通过秘钥派生函数（KDF）通过主秘钥派生出来的派生密码加密（对报文本身加密以及对报文完整性进行检测（需要认证秘钥））：

1）Kc：客户端 -》 客户端，报文加密秘钥
2）Mc：客户端 -》 客户端，报文认证码的 认证秘钥 MAC（Message Authentication Code，报文认证码）
2）Ks：服务端 -》 服务端，报文加密秘钥
2）Ms：服务端 -》 服务端，报文认证码的 认证秘钥
